\chapter{Week 4: Diepere duik}
Deze week gaan kijken naar enkele concepten die ons leven als programmeur een stukje makkelijker kunnen gaan maken. We gaan eerst een blik werpen op verzamelingen in de vorm van \textit{lijsten}. Daarna de robuustheid van onze code aanzienlijk verbeteren met \pyth{Try} / \pyth{Except}-blokken en ten slotte meer structuur aanbrengen met de introductie van \textit{functies}. 
% , \textit{Dictionaries} en \textit{tuples}

\section{Lijsten}\index{Lijsten}


% \section{Tuples}\index{Tuples}

% \section{Dictionaries}\index{Dictionaries}

\section{Try ... Except}\index{Try ... Except}
Je bent ze inmiddels ongetwijfeld tijdens het maken van de huiswerkopdrachten (of elders) tegengekomen: \textit{errors}. Bijv. bij het opvragen van gegevens bij de gebruiker, via de \pyth{input()}-functie:
\begin{python}
x = input('Geef een cijfer: ')
x = int(x)  # Zet de input-string om naar een int, en sla dit weer op in 'x'.
x += 1  # Tel er 1 bij op
print(f'Een hoger is: {x}')
\end{python}
Deze code runt doorgaans prima:
\begin{python}
Geef een cijfer: 12
Een hoger is: 13
\end{python}
Maar wat nu als de gebruiker iets verkeerds intypt? Bijv. een letter:
\begin{python}
Geef een cijfer: q
Traceback (most recent call last):
  File "/Users/stefan/Code/Python/err_test.py", line 2, in <module>
    x = int(x)  # Zet de input-string om naar een int, en sla dit weer op in 'x'.
ValueError: invalid literal for int() with base 10: 'q'
\end{python}
Dan krijg je dus een \textit{error} voor je kiezen, in dit geval een \pyth{ValueError}. Bijkomend nadeel: het programma sluit direct af (crasht). Gelukkig geeft \pyth{Python} bij errors vaak genoeg informatie waarmee je de bug je in je code kunt oplossen. Hierboven kun je lezen dat er iets mis gaat op regel $2$: \pyth{x = int(x)}, op het moment dat we de \pyth{str} $q$ om proberen te zetten naar een \pyth{int}. En dat is best te verklaren natuurlijk, $q$ is domweg geen getal. 

\begin{remark}
\textbf{Tip: } Mocht je nu op zoek zijn naar de \textit{ASCII}-waarde van een karakter, gebruik dan de \pyth{ord()}-functie:
\begin{python}
>>> ord('a')
97
>>> ord('b')
98
\end{python}
\end{remark}

Een gebruiker kan nou eenmaal iets verkeerds intypen en het zou vrij suf zijn als dan elke keer je programma crasht. Vandaar dat er in \textit{Python} functionaliteit zit om dit soort fouten van buitenaf af te vangen en op te reageren. Dit doen we door onze kritische code (in dit geval het omzetten van een \pyth{str} naar een \pyth{int}: \pyth{x = int(x)}) in een \pyth{try} / \pyth{except} blok te zetten. En dat ziet er als volgt uit:

\begin{python}
x = input('Geef een cijfer: ')
try:
	x = int(x)  # Zet de input-string om naar een int, en sla dit weer op in 'x'.
	x += 1  # Tel er 1 bij op
	print(f'Een hoger is: {x}')
except ValueError:
    print('Dat was geen getal, probeer het nog eens')
\end{python}

Hier 'proberen' we de \pyth{str} te interpreteren als een \pyth{int}. Gaat dat goed, dan wordt er netjes de rest van de code uitgevoerd. Krijg je een error, dan wordt het stuk code na de \pyth{except} uitgevoerd, en wordt de gebruiker vriendelijk verzocht 'even normaal te doen' en het nog eens te proberen. \newline

Elke error die je tegenkomt kun je op deze manier afvangen. Let daar wel bij op, dat niet elke error afgevangen hoeft te worden. Fouten die je zelf als programmeur maakt horen daar vaak niet bij, het gaat meer om fouten van 'buitenaf'. Bijv. je probeert connectie te maken met een server, maar die is op het moment uit de lucht. Dan zul je wellicht iets in de trant van een \pyth{ConnectionError} of een \pyth{TimeOutError} krijgen, die zijn handig om af te vangen. Je wilt niet dat door iets van buitenaf je programma crasht. Voor de liefhebber: hier is een lijstje te zien van de errors die standaard te vinden zijn in \textit{Python}: \url{https://docs.python.org/3/library/exceptions.html}.

\newpage

\section{Functies}\index{Functies}
\textit{Functies} waren we ook al tegengekomen in \textit{C}, in \textit{Python} is de opzet ervan hetzelfde: Een blok aan code, die alleen wordt uitgevoerd als de functie wordt 'aangeroepen'. Je maakt ze aan ('definieert' ze) met \pyth{def}, zie ook het onderstaande voorbeeld:

\begin{python}
def my_function():
    print('Hallo vanuit een functie!') 

my_function()
print('Hallo vanuit het hoofdprogramma!')
my_function()
\end{python}

Dit produceert de volgende output:

\begin{python}
Hallo vanuit een functie!
Hallo vanuit het hoofdprogramma!
Hallo vanuit een functie!
\end{python}

Je ziet in het programma op de eerste $2$ regels de gemaakte functie, na het woordje \pyth{def}. De naam van de functie is \textit{my\_function}, alle regels die daarna volgen en ingesprongen zijn (tab), horen bij deze functie. 
In dit geval is dit maar $1$ regel, namelijk een \pyth{print()}. \newline

Daarna wordt deze functie 'aangeroepen', dat gebeurt voor het eerst op regel $4$. Dat doe je dus door de naam van de functie te typen, gevolgd door $2$ haakjes $( )$. Even later op regel $6$ gebeurt hetzelfde nog eens. \newline

Dit was een voorbeeld van een functie zonder argumenten. Vaak zul je ook functies zien en maken die dat juist wel hebben. Een argument is iets wat je meegeeft met de functie. Dat kunnen er zoveel zijn als je wilt, en ook van elk datatype. Hieronder een voorbeeld met $2$ argumenten, van het type \pyth{str}:

\begin{python}
def my_function(naam, vraag):
    print(f'Hallo {naam}! {vraag}?') 

my_function('Henk', 'Hoe gaat het')
my_function('Piet', 'Waddup')
\end{python}
De uitoer zal in dit geval zijn:
\begin{python}
Hallo Henk! Hoe gaat het?
Hallo Piet! Waddup?
\end{python}

Valt je op je dat nog steeds nergens het datatype hoeft aan te geven? \textit{Python} snapt dat het om \pyth{str} gaat, omdat je ze als zodanig meegeeft op regel $4$ en $5$. \newline

\newpage

Dan rest ons nog een ding om in te duiken, functies die iets teruggeven. Het kan zijn dat een functie een bepaalde operatie uitvoerd, en dat je het resultaat daarvan graag wil gebruiken verderop in je programma. Dat kan, net als in \textit{C} met \pyth{return}. Zie ook het volgende voorbeeld:

\begin{python}
import math 

def oppervlakte(r):
    # Berekend de oppervlakte van een cirkel ahv de straal.
    opp = r**2 * math.pi
    return opp

o10 = oppervlakte(10)
print(f'Oppervlakte cirkel, bij straal=10: {o10}')

print(f'Oppervlakte cirkel, bij straal=15: {oppervlakte(15)}')

o20 = oppervlakte(20)
print(f'Oppervlakte cirkel, bij straal=10: {o20:.2f}')
\end{python}

De functie \pyth{oppervlakte()} berekend de oppervlakte van een cirkel a.h.v. de meegegeven straal \pyth{r}. En hij wordt op drie verschillende manieren aangeroepen. Allereerst op regel $8$, met een straal van $r=10$, het antwoord hiervan wordt daarna opgeslagen in de variabele $o10$, die dan geprint wordt op het scherm. \newline

Daarna op regel $11$, wordt het aanroepen van de functie (met $r=15$) en het printen van de teruggegeven waarde gecombineerd tot een regel code. \newline

En tenslotte wordt de functie nog een keer aangeroepen voor $r=20$ op regel $13$. Bij het printen (regel $14$) gebeurt iets bijzonders, daar wordt namelijk aangegeven dat de uitvoer maar $2$ kommagetallen moet laten zien (dit komt door de \pyth{:.2f} in \pyth{print}). De uitvoer van het programma is dan ook:
\begin{python}
Oppervlakte cirkel, bij straal=10: 314.1592653589793
Oppervlakte cirkel, bij straal=10: 706.8583470577034
Oppervlakte cirkel, bij straal=10: 1256.64
\end{python}

Zoals ik vorige week stelde, kun je met functies in combinatie met de \pyth{gpiozero}-module leuke dingen doen. Zo kun je dus bijv. functies aanroepen, als er een bepaalde actie wordt uitgevoerd word, zoals het indrukken en het loslaten van een knop:
\begin{python}
from gpiozero import Buttons
from signal import pause

def ingedrukt():
	print('knop ingedrukt!')

def losgelaten():
	print('knop weer losgelaten!')

btn = Button(2)  # Drukknop zit op GPIO2

btn.when_pressed = ingedrukt    # Koppel functie bij het indrukken.
btn.when_released = losgelaten  # Koppel functie bij het loslaten.
pause()                         # Doe verder niets meer, maar sluit niet af.
\end{python}

\begin{exercise}
Voor het programma uit, en ga voor jezelf na wat er precies gebeurt.
\end{exercise}

\begin{remark}
Weet je nog uit Programmeren $1$, dat knoppen last kunnen hebben van het zogeheten \textit{bouncen}, waardoor het lijkt dat ze veel vaker ingedrukt worden, dan ze daadwerkelijk worden. Mocht je daar nu ook last van hebben, dan kun je met \pyth{gpiozero} vrij makkelijk de bounce-tijd instellen. Vervang regel $10$ door:
\begin{python}
# Drukknop zit op GPIO2 met 100ms bounce time:
btn = Button(2, bounce_time=0.1)  
\end{python}
\end{remark}

Het mooie van het kunnen koppelen van functies aan gebeurtenissen van een sensor (zoals hier in het geval van de drukknop), is dat dat ook functies kunnen zijn die gebruikt worden door actuatoren, zoals bijv. een LED. Een LED heeft een \pyth{on()}- en een \pyth{off()}-functie. Dus het koppelen van een LED aan een drukknop kan zo:

\begin{python}
from gpiozero import Buttons, LED
from signal import pause

btn = Button(2)  # Drukknop zit op GPIO2
led = LED(17)    # LED zit op GPIO17

btn.when_pressed = led.on    # Koppel het indrukken van de knop met led.on()
btn.when_released = led.off  # Koppel het loslaten van de knop met led.off()
pause()                      # Doe verder niets meer, maar sluit niet af.
\end{python}

De laatste regel \pyth{pause()}, zorgt dat het programma verder niets meer uitvoert, maar ook niet afsluit. In tegenstelling tot de \pyth{while True:} uit het vorige hoofdstuk, waardoor de \textit{Raspberry Pi} intensief gebruikt werd, kan hij in dit geval rustig andere taken doen. 

\newpage
\section{Huiswerkopdrachten}\index{Huiswerkopdrachten}
\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

\begin{exercise}
$\\$
\end{exercise}

